package co.com.infrastructure.persistence.repositories

import akka.Done
import cats.data.{ EitherT, NonEmptyList, Reader }
import co.com.domain.contracts.UserRepositoryBase
import co.com.domain.model.entities.User
import co.com.infrastructure.Types.{ EitherFResult, EitherTResult }
import co.com.infrastructure.persistence.generarUUID
import co.com.infrastructure.persistence.tables.{ UserRow, users }
import co.com.suite.error.{ FindError, SaveError, TransactionError }
import monix.eval.Task
import slick.basic.DatabaseConfig
import slick.jdbc.JdbcProfile
import slick.jdbc.PostgresProfile.api._

import java.sql.Timestamp
import java.time.LocalDateTime
import scala.concurrent.ExecutionContext

object UserRepository extends UserRepositoryBase {

  /**
   * Implementation with Task of Monix (Monix library)
   * Reduce boilerplate generated by future implementation because you
   * always need an implicit variable execution context to run an action
   */
  def add( user: User, validFrom: LocalDateTime ): Reader[DatabaseConfig[JdbcProfile], EitherTResult[Done]] = Reader {
    dbConfig: DatabaseConfig[JdbcProfile] =>

      val query = users += userToUserRow( user, validFrom )

      EitherT {
        Task.deferFuture( dbConfig.db.run( query ) )
          .map( _ => Right( Done ) )
          .onErrorRecover {
            case error: Throwable => Left( NonEmptyList.of( SaveError( "user" ), TransactionError( error.getMessage ) ) )
          }
      }
  }

  def findWithTask( username: String ): Reader[DatabaseConfig[JdbcProfile], EitherTResult[Option[User]]] = Reader {
    dbConfig: DatabaseConfig[JdbcProfile] =>

      val query = users.filter( _.username === username )

      EitherT {
        Task.deferFuture( dbConfig.db.run( query.result ) )
          .map( result => Right( result.headOption.map( userRowToUser ) ) )
          .onErrorRecover {
            case error: Throwable => Left( NonEmptyList.of( FindError( "user", username ), TransactionError( error.getMessage ) ) )
          }
      }
  }

  /**
   * Implementation with Scala concurrent future You can pass
   * the execution context in the method or define the execution context as a class variable
   */
  def findWithFuture( username: String )( implicit ec: ExecutionContext ): Reader[DatabaseConfig[JdbcProfile], EitherFResult[Option[User]]] = Reader {
    dbConfig: DatabaseConfig[JdbcProfile] =>

      val query = users.filter( _.username === username )

      EitherT {
        dbConfig.db.run( query.result )
          .map( result => Right( result.headOption.map( userRowToUser ) ) )
          .recover {
            case error: Throwable => Left( NonEmptyList.of( FindError( "user", username ), TransactionError( error.getMessage ) ) )
          }
      }
  }

  def generateId(): String = {
    s"u-$generarUUID"
  }

  private[repositories] def userToUserRow( user: User, validFrom: LocalDateTime ): UserRow = {
    UserRow( user.id, user.username, user.email, Timestamp.valueOf( validFrom ) )
  }

  private[repositories] def userRowToUser( user: UserRow ): User = {
    User( user.id, user.username, user.email )
  }

}
